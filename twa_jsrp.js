// Generated by CoffeeScript 1.7.1
(function() {
  var Jsrp_svg, format_jsrp, log, parse_jsrp_attr, pulse_speed, retrieve_all_pulse_objects, total_active_gradients;

  pulse_speed = 15;


  /*
   INIT
   parses dom, and formats array of objects
   cycles through objects applying pulse effect
   */

  document.addEventListener("DOMContentLoaded", function() {
    var jsrp_objects;
    jsrp_objects = retrieve_all_pulse_objects();
    setInterval((function() {
      var jsrp_obj, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = jsrp_objects.length; _i < _len; _i++) {
        jsrp_obj = jsrp_objects[_i];
        _results.push(jsrp_obj.advance_color(void 0));
      }
      return _results;
    }), pulse_speed);
  });


  /*
   Retrieve and format all dom elements with .jsrp into jsrp_obj_array
   @RETURN an array of formatted object for specific tag types
   */

  retrieve_all_pulse_objects = function() {
    var all_jsrp, jsrp_dom, _i, _len, _results;
    all_jsrp = document.querySelectorAll(".jsrp");
    _results = [];
    for (_i = 0, _len = all_jsrp.length; _i < _len; _i++) {
      jsrp_dom = all_jsrp[_i];
      _results.push(format_jsrp(jsrp_dom));
    }
    return _results;
  };


  /*
   preps a dom object for object creation and passes to class/constructor
   @param {DOM object} _jsrp_dom
   @RETURN a formatted jsrp type object
   */

  format_jsrp = function(_jsrp_dom) {
    var parent_node, parent_tag;
    parent_tag = _jsrp_dom.parentNode.tagName;
    parent_node = _jsrp_dom.parentNode;
    if (parent_tag === "g") {
      parent_node = _jsrp_dom.parentNode.parentNode;
    }
    if (parent_node.tagName === "svg") {
      return new Jsrp_svg(_jsrp_dom, parent_node);
    } else {

    }
  };


  /*
    Parses the values from the DOM Attr and returns them as
    an appropriately formatted array. This is done by retrieving
    the core hsl values as well as the speed in seconds @TODO stroke/fill
  
    @param {String} _dom_string - string retrieved by the dom
    @RETURN {array} - an array of mixed types and values
      @val {array} _h - hue movement range
      @val {int} _s - satruation percent as int
      @val {int} _l - lightness percent as int
      @val {int} _speed - speed for each step of the cycles
   */

  parse_jsrp_attr = function(_dom_string) {
    var _h, _i, _l, _s, _speed, _split_dom;
    _split_dom = _dom_string.split(" ");
    _i = 0;
    while (_i < _split_dom.length) {
      switch (_split_dom[_i].charAt(0)) {
        case "H":
          _h = _split_dom[_i].substring(2, _split_dom[_i].length - 1);
          break;
        case "S":
          _s = parseInt(_split_dom[_i].substring(2, _split_dom[_i].length - 1));
          break;
        case "L":
          _l = parseInt(_split_dom[_i].substring(2, _split_dom[_i].length - 1));
      }
      if (_split_dom[_i].charAt(_split_dom[_i].length - 1) === "s") {
        _speed = _split_dom[_i].substring(0, _split_dom[_i].length - 1);
        _speed = parseInt((parseFloat(_speed)) * 1000 / 360);
      }
      _i++;
    }
    _h = _h.split("->");
    return [_h, _s, _l, _speed];
  };

  total_active_gradients = 0;


  /*
   class structure for jsrp object for an SVG element
   @method constructor - initialized object and gets relevent information
   @method parse_color - parses colors into local params
    @param {String} raw_color - attr from dom formatted as "h1,h2 s1,s2 b1,b2"
   @mathod advance_color - increments the color within its ranges
   @method hsl_split - splits an array of format ["h1,h2", "s1,s2", "b1,b2"]
    into and array with format hx,sx,bx
    @param {Array} _color_data - format ["h1,h2", "s1,s2", "b1,b2"]
    @param {int} _key -  index for sub array (x)
   @method set_updated_gradient - formats and sets the gradient stops into the DOM
   */

  Jsrp_svg = (function() {
    function Jsrp_svg(jsrp_dom, parent_node) {
      this.jsrp_dom = jsrp_dom;
      this.parent_node = parent_node;
      total_active_gradients++;
      this.format_gradient_def();
      this.parse_color(this.jsrp_dom.getAttribute("data-jsrp"));
    }

    Jsrp_svg.prototype.parse_color = function(raw_color) {
      var color_data;
      color_data = parse_jsrp_attr(raw_color);
      this.stops = color_data[0];
      this.s = color_data[1];
      this.l = color_data[2];
      this.speed = color_data[3];
    };

    Jsrp_svg.prototype.advance_color = function() {
      var _i;
      _i = 0;
      while (_i < this.stops.length) {
        if (this.stops[_i] < 360) {
          this.stops[_i]++;
        } else {
          this.stops[_i] = 0;
        }
        _i++;
      }
      this.set_updated_gradient();
    };

    Jsrp_svg.prototype.format_gradient_def = function() {
      var _defs, _fillID;
      this.dom_id = "jsrp_grad_" + total_active_gradients;
      _fillID = "url(#jsrp_grad_" + total_active_gradients + ")";
      _defs = this.parent_node.getElementsByTagName("defs")[0];
      _defs.innerHTML = _defs.innerHTML + ("<radialGradient id=\"jsrp_grad_" + total_active_gradients + "\" cx=\"62.5\" cy=\"62.5\" r=\"87.0057\" gradientUnits=\"userSpaceOnUse\">\n</radialGradient>");
      return this.jsrp_dom.setAttribute("fill", _fillID);
    };

    Jsrp_svg.prototype.set_updated_gradient = function() {
      this.parent_node.getElementById(this.dom_id).innerHTML = "<stop  offset=\"0\" style=\"stop-color:hsl(" + this.stops[1] + "," + this.s + "%," + this.l + "%);\"/>\n<stop  offset=\"1\" style=\"stop-color:hsl(" + this.stops[0] + "," + this.s + "%," + this.l + "%);\"/>";
    };

    return Jsrp_svg;

  })();


  /*
  ////////////////////////////////////
  /// @DEV @ONLY @METHODS ////////////
  ////////////////////////////////////
   */


  /*
   Shorthand log to console
   @param {String} _statement - string to log
   */

  log = function(_statement) {
    return console.log(_statement);
  };

}).call(this);
